// Copyright (C) EzPermission by Krzysztof Narkiewicz (hello@ezaquarii.com)
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.ezaquarii.ezpermission;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Bundle;
import android.provider.Settings;
import android.support.v4.app.ActivityCompat;
import android.support.v4.content.ContextCompat;
import android.util.Log;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.Callable;

/**
 * This helper allows to dispatch an action that requires a permission.
 *
 * If permission is not granted, it will handle permission request flow,
 * including rationale and permission re-query.
 *
 * It can handle modal rationale, like an info dialog, and non-modal, when we
 * want to switch entire screen into certain mode.
 *
 * It handles permission revocation and grant via system settings too.
 */

/*
@startuml

[*] --> START : [isRationaleModal]
[*] --> RATIONALE : [!isRationaleModal]
START --> RATIONALE : DISPATCH\n[!isGranted &&\ncanShowRationale]
START --> REQUESTING : DISPATCH\n[!isGranted &&\n!canShowRationale]
START --> GRANTED : DISPATCH\n[isGranted]
RATIONALE ---> REQUESTING : DISPATCH
REQUESTING --> GRANTED : GRANTED
REQUESTING --> START : DENIED / onDenied()\n[canShowRationale &&\nisRationaleModal]
REQUESTING --> RATIONALE : DENIED / onDenied()\n[canShowRationale &&\n!isRationaleModal]
REQUESTING --> DENIED : DENIED\n[!canShowRationale]
GRANTED --> GRANTED : DISPATCH\n[isGranted]
GRANTED --> DENIED : DISPATCH\n[!isGranted]
DENIED --> DENIED : DISPATCH\n[!isGranted]
DENIED --> GRANTED : DISPATCH\n[isGranted]

GRANTED : entry: onGranted()
RATIONALE : entry: onRationale()
REQUESTING : entry: onRequest()
DENIED : entry: onDeniedPermanently()

@enduml
*/
public class EzPermission {

    private static final String TAG = EzPermission.class.getSimpleName();
    private static final String EXTRA_INSTANCE_STATE_DEBUG = EzPermission.class.getName() + ".DEGUG";
    private static final String EXTRA_INSTANCE_STATE_FSM_STATE = EzPermission.class.getName() + ".FSM_STATE";

    static class Fsm {

        enum State {
            START,
            RATIONALE,
            REQUESTING,
            GRANTED,
            DENIED
        }

        enum Event {
            DISPATCH,
            GRANTED,
            DENIED,
            REJECT
        }

        private static class Row {
            Row(State from, Event event, Callable<Boolean> guard, State to) {
                this.event = event;
                this.guard = guard;
                this.from = from;
                this.to = to;
            }

            Event event;
            Callable<Boolean> guard;
            State from;
            State to;

            boolean evaluate(State currentState, Event event) {
                try {
                    return this.from == currentState &&
                            this.event == event &&
                            (guard == null || guard.call());
                } catch (Exception ex) {
                    throw new RuntimeException(ex);
                }
            }
        }

        private static class StatePair {

            public final State from;
            public final State to;

            StatePair(State from, State to) {
                this.from = from;
                this.to = to;
            }

            /// Autogenerated
            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;

                StatePair that = (StatePair) o;

                if (from != that.from) return false;
                return to == that.to;
            }

            /// Autogenerated
            @Override
            public int hashCode() {
                int result = from != null ? from.hashCode() : 0;
                result = 31 * result + (to != null ? to.hashCode() : 0);
                return result;
            }
        }

        private Callable<Boolean> mIsGranted;
        private Callable<Boolean> mCanShowRationale;
        private Callable<Boolean> mIsRationaleModal;
        private Map<State, Runnable> mOnEntryCallbacks = new HashMap<>();
        private Map<StatePair, Runnable> mOnTransitionCallbacks = new HashMap<>();

        private Callable<Boolean> mNone = null;

        private Runnable mOnGranted;
        private Runnable mOnRationale;
        private Runnable mOnRequest;
        private Runnable mOnDenied;
        private Runnable mOnDeniedPermanently;

        private State mCurrentState = State.START;
        private boolean mDebug = false;
        private Row[] mFsmTable;

        Fsm(Callable<Boolean> isGranted, Callable<Boolean> canShowRationale, Callable<Boolean> isRationaleModal, Runnable onGranted, Runnable onRationale, Runnable onRequest, Runnable onDenied, Runnable onDeniedPermanently) {
            mIsGranted = isGranted;
            mCanShowRationale = canShowRationale;
            mIsRationaleModal = isRationaleModal;

            mOnGranted = onGranted;
            mOnRationale = onRationale;
            mOnRequest = onRequest;
            mOnDenied = onDenied;
            mOnDeniedPermanently = onDeniedPermanently;

            mFsmTable = new Row[] {
                    new Row(State.START,      Event.DISPATCH, mIsGranted,                        State.GRANTED),
                    new Row(State.START,      Event.DISPATCH, and(not(mIsGranted),
                                                                      mCanShowRationale),        State.RATIONALE),
                    new Row(State.START,      Event.DISPATCH, and(not(mIsGranted),
                                                                  not(mCanShowRationale)),       State.REQUESTING),
                    new Row(State.RATIONALE,  Event.DISPATCH, mNone,                             State.REQUESTING),
                    new Row(State.RATIONALE,  Event.REJECT,   mIsRationaleModal,                 State.START),
                    new Row(State.REQUESTING, Event.GRANTED,  mNone,                             State.GRANTED),
                    new Row(State.REQUESTING, Event.DENIED,   and(mCanShowRationale,
                                                                  mIsRationaleModal),            State.START),
                    new Row(State.REQUESTING, Event.DENIED,   and(mCanShowRationale,
                                                                  not(mIsRationaleModal)),       State.RATIONALE),
                    new Row(State.REQUESTING, Event.DENIED,   not(mCanShowRationale),            State.DENIED),
                    new Row(State.DENIED,     Event.DISPATCH, not(mIsGranted),                   State.DENIED),
                    new Row(State.DENIED,     Event.DISPATCH, mIsGranted,                        State.GRANTED),
                    new Row(State.GRANTED,    Event.DISPATCH, not(mIsGranted),                   State.DENIED),
                    new Row(State.GRANTED,    Event.DISPATCH, mIsGranted,                        State.GRANTED)
            };

            mOnEntryCallbacks.put(State.GRANTED, mOnGranted);
            mOnEntryCallbacks.put(State.RATIONALE, mOnRationale);
            mOnEntryCallbacks.put(State.REQUESTING, mOnRequest);
            mOnEntryCallbacks.put(State.DENIED, mOnDeniedPermanently);

            mOnTransitionCallbacks.put(new StatePair(State.REQUESTING, State.START), mOnDenied);
            mOnTransitionCallbacks.put(new StatePair(State.REQUESTING, State.RATIONALE), mOnDenied);
        }

        void start() {
            try {
                if (mIsRationaleModal.call()) {
                    mCurrentState = State.START;
                } else {
                    mCurrentState = State.RATIONALE;
                }
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            }
        }

        State getCurrentState() {
            return mCurrentState;
        }

        void setCurrentState(State state) {
            mCurrentState = state;
        }

        void event(Event event) {
            for(Row row : mFsmTable) {
                if(row.evaluate(mCurrentState, event)) {
                    if(mDebug) {
                        String msg = String.format("event: %s, from: %s, to: %s", row.event, row.from, row.to);
                        Log.d(TAG, msg);
                    }
                    StatePair currentTransition = new StatePair(mCurrentState, row.to);
                    Runnable onTransition = mOnTransitionCallbacks.get(currentTransition);
                    if(onTransition != null) {
                        onTransition.run();
                    }
                    mCurrentState = row.to;
                    Runnable onEntry = mOnEntryCallbacks.get(mCurrentState);
                    if(onEntry != null) {
                        onEntry.run();
                    }
                    break;
                }
            }
        }

        void setDebug(boolean debug) {
            mDebug = debug;
        }

        boolean getDebug() {
            return mDebug;
        }
    }

    private Activity mActivity;
    private int mRequestCode;
    private String mPermission;
    private boolean mIsRationaleModal = false;

    private Runnable mOnGrantedAction;
    private Runnable mOnRationaleAction;
    private Runnable mOnDeniedAction;
    private Runnable mOnDeniedPermanentlyAction;

    private Callable<Boolean> mIsPermissionGrantedGuard = new Callable<Boolean>() {
        @Override
        public Boolean call() throws Exception {
            return hasPermission(mActivity, mPermission);
        }
    };

    private Callable<Boolean> mCanShowRationaleGuard = new Callable<Boolean>() {
        @Override
        public Boolean call() throws Exception {
            return ActivityCompat.shouldShowRequestPermissionRationale(mActivity, mPermission) && mOnRationaleAction != null;
        }
    };

    private Callable<Boolean> mIsRationaleModalGuard = new Callable<Boolean>() {
        @Override
        public Boolean call() throws Exception {
            return mIsRationaleModal;
        }
    };

    private Runnable mOnRequestPermissionAction = new Runnable() {
        @Override
        public void run() {
            ActivityCompat.requestPermissions(mActivity, new String[] {mPermission}, mRequestCode);
        }
    };

    private Fsm mFsm;

    private String mExtraInstanceDebug;
    private String mExtraInstanceFsmState;

    /**
     * Create permissions helper.
     *
     * @param activity Activity used to request for a permission
     * @param requestCode Expected request code; helper will not handle results with invalid request code
     * @param permission Permission to ask for
     * @param isRationaleModal True if rationale is modal (like a dialog), false otherwise; consult state machine diagram to see behavioral change
     * @param onGranted Called when permission is granted
     * @param onRationale Called when rationale should be shown
     * @param onDenied Called when permission is denied; permission can be requested again
     * @param onDeniedPermanantly Called when permission is denied permanently
     */
    public EzPermission(Activity activity, int requestCode, boolean isRationaleModal, String permission, Runnable onGranted, Runnable onRationale, Runnable onDenied, Runnable onDeniedPermanantly) {
        this(activity, requestCode, isRationaleModal, permission, onGranted, onRationale, onDenied, onDeniedPermanantly, null, null, null);
    }

    /**
     * Create permissions helper with custom permission request routine and custom
     * rationale check. This is indented to be used in test only.
     *
     * @param activity Activity used to request for a permission
     * @param requestCode Expected request code; helper will not handle results with invalid request code
     * @param permission Permission to ask for
     * @param isRationaleModal True if rationale is modal (like a dialog), false otherwise; consult state machine diagram to see behavioral change
     * @param onGranted Called when permission is granted
     * @param onRationale Called when rationale should be shown
     * @param onDenied Called when permission is denied; permission can be requested again
     * @param onDeniedPermanantly Called when permission is denied permanently
     * @param onRequest Called when permission should be requested; when null, default behaviour will be used
     * @param canShowRationale Should return true if rationale should be shown, false otherwise; when null, default guard will be used
     * @param isPermissionGranted Should return true if permission is granted, false otherwise; when null, default guard will be used
     */
    public EzPermission(Activity activity,
                        int requestCode,
                        boolean isRationaleModal,
                        String permission,
                        Runnable onGranted,
                        Runnable onRationale,
                        Runnable onDenied,
                        Runnable onDeniedPermanantly,
                        Runnable onRequest,
                        Callable<Boolean> canShowRationale,
                        Callable<Boolean> isPermissionGranted) {

        mExtraInstanceDebug = String.format("%s:%s", EXTRA_INSTANCE_STATE_DEBUG, permission);
        mExtraInstanceFsmState = String.format("%s:%s", EXTRA_INSTANCE_STATE_FSM_STATE, permission);

        if(onRequest != null) {
            mOnRequestPermissionAction = onRequest;
        }
        if(canShowRationale != null) {
            mCanShowRationaleGuard = canShowRationale;
        }
        if(isPermissionGranted != null) {
            mIsPermissionGrantedGuard = isPermissionGranted;
        }

        mActivity = activity;
        mRequestCode = requestCode;
        mPermission = permission;
        mIsRationaleModal = isRationaleModal;

        mOnGrantedAction = onGranted;
        mOnRationaleAction = onRationale;
        mOnDeniedAction = onDenied;
        mOnDeniedPermanentlyAction = onDeniedPermanantly;

        mFsm = new Fsm(
                mIsPermissionGrantedGuard,
                mCanShowRationaleGuard,
                mIsRationaleModalGuard,
                mOnGrantedAction,
                mOnRationaleAction,
                mOnRequestPermissionAction,
                mOnDeniedAction,
                mOnDeniedPermanentlyAction
        );

        mFsm.start();
    }

    /**
     * Save instance state to a provided bundle. It will use extras key with
     * full class name, so there should be no key name conflict.
     *
     * @param outState Bundle to save state to.
     */
    public void saveInstanceState(Bundle outState) {
        if(outState != null) {
            outState.putBoolean(mExtraInstanceDebug, mFsm.getDebug());
            outState.putSerializable(mExtraInstanceFsmState, mFsm.getCurrentState());
        }
    }

    /**
     * Restore instance state from provided bundle. If no state has been saved,
     * this call has no effect.
     * @param inState Input bundle with saved instance state.
     */
    public void restoreInstanceState(Bundle inState) {
        if(inState != null) {
            if (inState.containsKey(mExtraInstanceDebug)) {
                boolean debug = inState.getBoolean(mExtraInstanceDebug, false);
                mFsm.setDebug(debug);
            }

            if (inState.containsKey(mExtraInstanceFsmState)) {
                Fsm.State state = (Fsm.State) inState.getSerializable(mExtraInstanceFsmState);
                if (state == null) {
                    throw new IllegalStateException("Saved state machine instance state is null");
                }
                mFsm.setCurrentState(state);
            }
        }
    }

    /**
     * Set debug flag. In debug mode, state machine transitions are printed using {@link Log}.
     * By default debug is set to false.
     *
     * @param debug true to enable state machine debug log, false to disable
     */
    public void setDebug(boolean debug) {
        mFsm.setDebug(debug);
    }

    /**
     * Get current state machine debug flag
     *
     * @return Debug flag
     */
    public boolean getDebug() {
        return mFsm.getDebug();
    }

    /**
     * Call code that requires permission. If permission is not granted,
     * state machine will handle the flow to request the permission.
     */
    public void call() {
        mFsm.event(Fsm.Event.DISPATCH);
    }

    /**
     * Notify the state machine that rationale has been accepted. It must be called
     * when users accepts rationale (ex. when user taps Ok in rationale dialog).
     */
    public void acceptRationale() {
        call();
    }

    /**
     * Notify the state machine that rationale has been rejected. It must be called
     * when users rejects rationale (ex. when user taps Cancel in rationale dialog).
     */
    public void rejectRationale() {
        mFsm.event(Fsm.Event.REJECT);
    }

    /**
     * This methods should be called in {@link Activity#onRequestPermissionsResult(int, String[], int[])}.
     */
    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
        if(requestCode == mRequestCode) {
            if(isGranted(permissions, grantResults, mPermission)) {
                mFsm.event(Fsm.Event.GRANTED);
            } else {
                mFsm.event(Fsm.Event.DENIED);
            }
        }
    }

    public void setModalRationale(boolean modal) {
        mIsRationaleModal = modal;
    }

    Fsm.State getCurrentState() {
        return mFsm.getCurrentState();
    }

    private String createStateExtraKey(String keyPrefix) {
        return String.format("%s:%s", keyPrefix, mPermission);
    }

    /**
     *  Launch system settings with application details configuration. This method
     *  should be used to allow user set app permissions.
     *
     * @param context Context used to launch settings activity
     */
    public static void launchApplicationDetailsSettings(Context context) {
        final Intent i = new Intent();
        i.setAction(Settings.ACTION_APPLICATION_DETAILS_SETTINGS);
        i.addCategory(Intent.CATEGORY_DEFAULT);
        i.setData(Uri.parse("package:" + context.getPackageName()));
        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        i.addFlags(Intent.FLAG_ACTIVITY_NO_HISTORY);
        i.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);
        context.startActivity(i);
    }

    private static boolean hasPermission(Context context, String permission) {
        int result = ContextCompat.checkSelfPermission(context, permission);
        return result == PackageManager.PERMISSION_GRANTED;
    }

    private static boolean isGranted(String[] permissions, int[] grantResults, String permission) {
        if(permission == null || permissions == null || grantResults == null) {
            throw new IllegalArgumentException("Permission, requested permissions and grant result cannot be null");
        }
        if(permissions.length != grantResults.length) {
            throw new IllegalArgumentException("Permissions and grant result size differ");
        }
        for(int i = 0; i < permissions.length; i++) {
            if(permission.equals(permissions[i])) {
                return grantResults[i] == PackageManager.PERMISSION_GRANTED;
            }
        }
        return false;
    }

    private static Callable<Boolean> not(final Callable<Boolean> call) {
        return new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                return !call.call();
            }
        };
    }

    @SafeVarargs
    private static Callable<Boolean> and(final Callable<Boolean>... calls) {
        return new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                for(Callable<Boolean> call : calls) {
                    if(!call.call()) {
                        return false;
                    }
                }
                return true;
            }
        };
    }

    @SafeVarargs
    private static Callable<Boolean> or(final Callable<Boolean>... calls) {
        return new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                for(Callable<Boolean> call : calls) {
                    if(call.call()) {
                        return true;
                    }
                }
                return false;
            }
        };
    }
}
